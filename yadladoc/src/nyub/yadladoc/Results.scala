package nyub.yadladoc

import munit.diff.Diffs

import java.nio.file.Path
import scala.collection.mutable.ArrayBuffer

case class Results[A](
    val results: A,
    val errors: Seq[Errors]
):
    /** @param f
      *   the transformation to apply to `this.results`
      * @return
      *   a results with the errors = `this.errors` and results =
      *   `f(this.results)`
      */
    def map[B](f: A => B): Results[B] =
        Results(f(results), errors)

    /** @param error
      *   the error to append to this results
      * @return
      *   this results with an additionna error appended to `this.errors`
      */
    def withError(error: Errors): Results[A] = Results(results, errors :+ error)

    /** @param f
      *   the transformation to apply to `this.results`, possibly yielding
      *   errors
      * @return
      *   results with results = `f(this.results).results` and errors =
      *   `this.errors` ++ `f(this.results).errors`
      */
    def flatMap[B](f: A => Results[B]): Results[B] =
        val nextResults = f(results)
        Results(nextResults.results, errors ++ nextResults.errors)

    /** @param other
      *   other [[Results]]
      * @param f
      *   combination to apply to `this.results` and `other.results`
      * @return
      *   results with results = `f(this.results, other.results)` and errors
      *   being the merge of the two results' errors. The largest common prefix
      *   of errors are shared in the merged errors.
      */
    def merge[B, C](other: Results[B])(
        f: (A, B) => Results[C]
    ): Results[C] =
        val nextResults = f(results, other.results)
        Results(
          nextResults.results,
          mergeErrors(other.errors) ++ nextResults.errors
        )

    private def mergeErrors(right: Seq[Errors]): Seq[Errors] =
        val leftLen = errors.size
        val rightLen = right.size
        val merged = ArrayBuffer.empty[Errors]
        var commonIndex = 0
        while commonIndex < Math.min(leftLen, rightLen) && errors(
              commonIndex
            ) == right(commonIndex)
        do
            merged.addOne(errors(commonIndex))
            commonIndex += 1
        for i <- commonIndex until leftLen do merged.addOne(errors(i))
        for i <- commonIndex until rightLen do merged.addOne(right(i))
        merged.toSeq

object Results:
    /** @return
      *   results without errors
      */
    def success[A](results: A): Results[A] = Results(results, Seq.empty)

sealed trait Errors:
    def prettyPrintedMessage: String

/** Error spawned when specifying an unknown
  * [[nyub.interpreter.ScriptDecorator]]'s id
  */
case class MissingDecoratorError(val decoratorId: String) extends Errors:
    override def prettyPrintedMessage: String =
        s"Unknown decorator id '${decoratorId}'"

/** Errors spawned when comparing the actual file system to what would have have
  * been generated by a [[Yadladoc]] run
  */
sealed trait CheckErrors extends Errors

object CheckErrors:
    /** A file would have been generated but is not present in actual file
      * system
      *
      * @param generatedFileName
      *   path to the file that would have been generated
      */
    case class MissingFile(generatedFileName: Path) extends Errors:
        override def prettyPrintedMessage: String =
            s"File '${generatedFileName}' is missing"

    /** A generated file would differs from its counterpart in the actual file
      * system
      *
      * @param fileName
      *   generated file path
      * @param actualContent
      *   content in actual file system
      * @param expectedContent
      *   content that would have been generated
      */
    case class MismatchingContent(
        fileName: Path,
        actualContent: String,
        expectedContent: String
    ) extends Errors:
        override def prettyPrintedMessage: String =
            val diff = Diffs.create(actualContent, expectedContent)
            s"""File '${fileName}' has mismatching content with what would have been generated
${diff.unifiedDiff}"""

/** A file generated from a documentation example
  *
  * @param parent
  *   optional root of generated file path
  * @param relative
  *   generated file path relative to `parent` or absolute if `parent` is `None`
  * @param from
  *   path pointing to the documentation file this [[GeneratedFile]] was
  *   generated from
  */
case class GeneratedFile(
    private val parent: Option[Path],
    private val relative: Path,
    val from: Path
):
    /** @return
      *   full path to the generated file
      */
    def full: Path = parent.map(_.resolve(relative)).getOrElse(relative)

    /** @return
      *   short version of the generated file from which `parent` root may have
      *   been stripped
      */
    def short: Path = relative
